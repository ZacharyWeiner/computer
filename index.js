"use strict";function t(t){return t&&"object"==typeof t&&"default"in t?t.default:t}var e=t(require("socket.io-client"));var s=t(require("bitcoinsource"));var n=t(require("axios"));var r=t(require("eventemitter3"));const o="mainnet";const a=546;const i=2e3;const c=2e4;const u=479;const h="https://bch.blockdozer.com/api";const d="http://bitcoinbroadcastserver-env.r5t6c3b2kj.us-west-1.elasticbeanstalk.com";const p="ws://bitcoinbroadcastserver-env.r5t6c3b2kj.us-west-1.elasticbeanstalk.com:8020";var l={BITCOIN_NETWORK:o,BLOCK_EXPLORER_URL:h,MIN_SATOSHI_AMOUNT:a,MIN_NON_DUST_AMOUNT:i,SCRIPT_CHUNK_SIZE:u,UN_P2SH_URL:d,DEFAULT_FEE:c,WS_URL:p};s.versionGuard=()=>!0,s.Networks.defaultNetwork=s.Networks[l.BITCOIN_NETWORK];class m extends Error{constructor(t,e,...s){super(...s),this.name="Error",this.message=t+(e?`: ${e}`:""),Error.captureStackTrace&&Error.captureStackTrace(this,m)}}function _(t){return{writable:!0,value:t}}function f(t,e,{[t]:s,...n}){return{[e]:s,...n}}const w=async t=>{try{return(await t).data}catch(t){if(t.response){const{status:e,statusText:s,data:n}=t.response;const{method:r,url:o}=t.response.config||{method:"unknown",url:"unknown"};const a=t.response.config.data;const i=n.error||(-1!==n.indexOf("Code:")?n:s);throw new m(`\nCommunication Error\n\nstatus\t${e} ${s}\nmessage\t${i}\nrequest\t${r} ${o}${a?`\ndata\t${a}`:""}`)}throw new m("Communication error","Service unavailable.")}};const g=async(t,e=l.BLOCK_EXPLORER_URL)=>w(n.get(`${e}${t}`));const S=async(t,e,s=l.BLOCK_EXPLORER_URL)=>w(n.post(`${s}${t}`,e));const y=async t=>g(`/addr/${t.toString()}`);const O=async t=>{const{balanceSat:e,unconfirmedBalanceSat:s}=await y(t);return e+s};const b=async t=>f("txid","txId",await S("/tx/send",{rawtx:t.toString()}));const I=t=>t.filter((t,e,s)=>s.findIndex(e=>e.txId===t.txId&&e.vout===t.vout)===e);const x=async t=>g(`/tx/${t}`);const v=async t=>(await g(`/rawtx/${t}`)).rawtx;const P=async t=>{const e=t.toString();const s=(await g(`/addr/${e}/utxo`)).map(({txid:t,...e})=>Object.assign(e,{txId:t}));return I(s).map(t=>(t.spent=!1,t))};const N=async t=>{const e=t.map(t=>t.__txId);const s=[...new Set(e)];const n=new Map;return await Promise.all(s.map(async t=>n.set(t,await x(t)))),t.map(t=>{const{vout:e,blockheight:s,confirmations:r}=n.get(t.__txId)||{};return t.__vouts.map(n=>{const{scriptPubKey:o,value:a,spentTxId:i}=e[n];return{address:o.addresses[0],txId:t.__txId,vout:n,scriptPubKey:o.hex,amount:parseFloat(a),satoshis:parseInt(1e8*a,10),height:s,confirmations:r,spent:!!i}})})};const k=async t=>S("/",t,l.UN_P2SH_URL);const E=async t=>g(`/un-p2sh/${t}`,l.UN_P2SH_URL);const D=async t=>S("/txos/set-spent/",t,l.UN_P2SH_URL);class T{constructor(t){this.kind=t}toJSON(){return{}}static async fromOutputId(t){const{txId:e,virtualIndex:s}=t;return(await E(e))[s]}}const{PublicKey:K,Transaction:R,Script:U}=s;class A extends T{constructor(t={}){super("script"),Object.assign(this,t),this._amount=t._amount||l.MIN_NON_DUST_AMOUNT}getData(t){return this[t]}getSerializeData(){const{kind:t,_owners:e,_amount:s,...n}=this;return Buffer.from(JSON.stringify(n))}static fromMultiSigScriptHashInput(t){const{_scriptBuffer:e}=t;const s=q.fromBuffer(e);const{redeemScript:n=q.redeemScriptFromP2shScript(s)}=t;return this.fromRedeemScript(n)}static fromRedeemScript(t){return this.fromRedeemScripts([t])}static fromRedeemScripts(t){const e=t.map(t=>t.chunks[t.chunks.length-2].buf);const s=Buffer.concat(e);const n=JSON.parse(s.toString());return Object.assign(new this,{kind:"script",_owners:t[0].getPublicKeys(),_amount:l.MIN_NON_DUST_AMOUNT,...n})}static addVouts(t){let e=0;return t.map(t=>{const s="script"===t.kind?q.outScriptFromData(t).length:1;return t.__vouts=Array(s).fill(e).map((t,e)=>t+e),e+=s,t})}toJSON(){return{...this,kind:"script",_owners:(this._owners||[]).map(t=>t.toString()),_amount:l.MIN_NON_DUST_AMOUNT}}static isJSON(t){return"script"===t.kind}static fromJSON(t){const e={...t};return e._owners=(e._owners||[]).map(t=>new K(t)),new A(e)}}const{PublicKey:j,Address:J,Transaction:M}=s;class $ extends T{constructor(t,e){super("pkh"),this.address=t,this.amount=e}static fromPublicKeyHashInput(t){const{output:e}=t;return new this(e.script.toAddress(),e.satoshis)}toJSON(){return{kind:"pkh",address:this.address.toString(),amount:this.amount}}static isJSON(t){return t.address&&t.amount}static fromJSON(t){return new this(new J(t.address),t.amount)}}class C extends T{constructor(t){super("return"),this.data=t||""}getData(){return this.data}toJSON(){return{kind:"return",data:this.data}}static isJSON(t){return!!t.data}static fromJSON(t){return new this(t.data)}}const{Address:H,PublicKey:L,Signature:B,Script:F,Opcode:z}=s;function W(t,e){const s=[];let n=0;for(;n<t.length;)s.push(t.slice(n,n+e)),n+=e;return s}class q extends F{static outScriptFromData({kind:t,_owners:e=[],_amount:s,__vouts:n,__txId:r,...o}){const a=W(Buffer.from(JSON.stringify(o)),l.SCRIPT_CHUNK_SIZE);return a[a.length-1].byteLength>=l.SCRIPT_CHUNK_SIZE&&W(a.pop(),l.SCRIPT_CHUNK_SIZE).forEach(t=>{a.push(t)}),a.map(t=>{const s=new q;return s.add("OP_1"),e.forEach(t=>s.add(t.toBuffer())),s.add(`OP_${e.length}`),s.add("OP_CHECKMULTISIG"),s.add(t),s.add("OP_DROP"),{redeemScript:s,chunk:t}})}getPublicKeys(){let t=1;const e=[];for(;this.chunks[t].buf;)e.push(new L(this.chunks[t].buf)),t+=1;return e}static inScriptFromData(t,e,s,n){const r=new q;return s.forEach(t=>{r.add(t)}),r.add(r),r}isDbDataScript(){return!(!(this.chunks.length>=5&&this.chunks[0].opcodenum===z.OP_1&&this.chunks[1].buf)||20!==this.chunks[1].buf.length&&33!==this.chunks[1].buf.length||this.chunks[2].opcodenum!==z.OP_1||this.chunks[3].opcodenum!==z.OP_CHECKMULTISIG||!this.chunks[4].buf||this.chunks[5].opcodenum!==z.OP_DROP)}static isP2shScript(t){return!(3!==t.chunks.length||t.chunks[0].opcodenum!==z.OP_0||!t.chunks[1].buf||!t.chunks[2].buf)}static redeemScriptFromP2shScript(t){if(!this.isP2shScript(t))throw new Error("not a p2sh script");const e=new F(t.chunks[2].buf);const s=new this;return s.chunks=e.chunks,s}static fromScript(t){const e=new F(t);const s=new q;return s.chunks=e.chunks,s}}const{PublicKey:V,Address:Z}=s;class G extends T{constructor(t){super("change"),this.address=t}toJSON(){return{kind:"change",address:this.address.toString()}}static isJSON(t){return t.address}static fromJSON(t){return new this(new Z(t.address))}}const X=t=>"object"==typeof t?Object.prototype.toString.call(t).match(/\s([a-zA-Z]+)/)[1]:Object.prototype.toString.call(t).match(/\s([a-zA-Z]+)/)[1].toLowerCase();const Q=t=>["undefined","number","string","boolean","Null"].includes(X(t));const Y=t=>Q(t)||["Array","Object"].includes(X(t));const tt=t=>t===parseInt(t,10).toString();const et=(t,e)=>{if(!Y(t)||!Y(e))throw new Error(`Unsupported data types for deep equals: ${X(t)} & ${X(e)}`);return X(t)===X(e)&&(Q(t)&&Q(e)?t===e:t&&e&&Object.entries(t).every(([t,s])=>et(e[t],s))&&Object.entries(e).every(([e,s])=>et(t[e],s)))};const st=t=>{if(Q(t))return t;if("Array"===X(t))return t.map(t=>st(t));if("Object"===X(t)){const e=Object.keys(t).reduce((e,s)=>(e[s]=st(t[s]),e),{});const s=Object.create(Object.getPrototypeOf(t));return Object.assign(s,e)}throw new Error(`Unsupported data type for clone: ${X(t)}`)};const nt=(t,e=0,s=[])=>{const n=e;s[e]={};for(const r of Object.keys(t))r.startsWith("_")?s[n][r]=t[r]:Q(t[r])?s[n][r]="_":(e+=1,s[n][r]=e,({res:s,pos:e}=nt(t[r],e,s)));return{res:s,pos:e}};const rt=(t,e=0)=>{const s=t[e];if(void 0===s)return"_";const n=Object.keys(s).every(tt)?[]:{};for(const e of Object.keys(s))e.startsWith("_")?n[e]=s[e]:n[e]=rt(t,s[e]);return n};const{Mnemonic:ot,HDPrivateKey:at,PrivateKey:it,PublicKey:ct,Address:ut,OutputData:ht}=s;class dt{constructor(t){this.mnemonic=t||new ot,this.path="",this.hdPrivateKey=this.mnemonic.toHDPrivateKey(this.path,l.BITCOIN_NETWORK)}static getRandomMnemonic(){return(new ot).toString()}static fromMnemonic(t){return new dt(t)}getMnemonic(){return this.mnemonic}getPath(){return this.path}derive(t=0,e=!1){const s=new dt(this.mnemonic);return s.path=`${this.path}${this.path.length?"/":""}${t}${e?"'":""}`,s.hdPrivateKey=this.hdPrivateKey.derive(t,e),s}static getHdPrivateKey(){return new at}getPrivateKey(){return this.hdPrivateKey.privateKey}getPublicKey(){return this.hdPrivateKey.publicKey}getAddress(){return this.address=this.address||this.getPublicKey().toAddress(),this.address}async getBalance(){const t=this.getAddress();return O(t.toString())}async getUtxos(t,e=this.getAddress()){const s=await P(e);for(let t=s.length-1;t>0;t-=1){const e=Math.floor(Math.random()*(t+1));const n=s[t];s[t]=s[e],s[e]=n}let n=0;const r=[];let o=0;for(;n<t&&o<s.length;)r.push(s[o]),n+=s[o].satoshis,o+=1;if(n<t)throw new Error(`Insufficient balance in address ${e.toString()}`);return r}async sendTransaction(t,e=!1){const{txId:s}=await b(t);if(e){const e=JSON.stringify(t.outputData.map(t=>t.toJSON()));const n=t.toJSON().inputs.map(({prevTxId:t,outputIndex:e})=>({txId:t,outputIndex:e}));await k({txId:s,outputData:e,inputs:n})}return{txId:s}}async send(t,e){const s=new Pt;const n=e||this.getAddress();const r=l.DEFAULT_FEE;const o=this.getPrivateKey();const a=t.reduce((t,e)=>t+parseInt(e.amount||0,10),0);return(await this.getUtxos(a+r)).forEach(s.from.bind(s)),t.forEach(s.to.bind(s)),s.change(n),s.sign(o),this.sendTransaction(s)}async sendAll(t){const e=await this.getBalance();const s=l.DEFAULT_FEE;if(e>s){const n=new $(t,e-s);return this.send([n])}throw new Error("Insufficient funds to send payment.")}}class pt{static fromJSON(t){if(A.isJSON(t))return A.fromJSON(t);if($.isJSON(t))return $.fromJSON(t);if(G.isJSON(t))return G.fromJSON(t);if(C.isJSON(t))return C.fromJSON(t);throw new Error(`unrecognized json ${JSON.stringify(t)}`)}}class lt{constructor(t){this.wallet=t||new dt}static fromMnemonic(t){return new this(new dt(t))}async put(t){return this.update([],t)}async get(t){return lt.get(t)}static async getOutputDataMap(t){const e=[...new Set(t)];const s=await Promise.all(e.map(async t=>{const e=(await E(t)).map(pt.fromJSON);let s=0;const n=e.map(e=>{const n="script"===e.kind?q.outScriptFromData(e).length:1;const r=Array(n).fill(s).map((t,e)=>t+e);return s+=n,{...e,__vouts:r,__txId:t}});return[t,n]}));return new Map(s)}static async get(t){const e=t.map(t=>t.txId);const s=await this.getOutputDataMap(e);return t.map(({txId:t,virtualIndex:e})=>{const n=s.get(t);if(!n||!Array.isArray(n))throw new Error("No data found.");return n[e]})}async update(t,e){const s=new Pt;const n=await this.get(t);const r=await N(n);t.forEach(async(t,e)=>{s.fromScriptOutput(r[e],n[e])});const o=e.map(s.to.bind(s));const a=(s._estimateSize()+20)*(l.DEFAULT_FEE/1e3);(await this.wallet.getUtxos(a)).forEach(s.from.bind(s)),s.fee(a),s.change(this.wallet.getAddress()),s.sign(this.wallet.getPrivateKey());const{txId:i}=await this.wallet.sendTransaction(s,!0);return t.forEach(async t=>{await D(t)}),o.map(t=>({txId:i,virtualIndex:t}))}}const{Transaction:mt,PublicKey:_t,Address:ft,BN:wt,Script:gt,encoding:St}=s;const{Output:yt,Input:Ot}=mt;const{MultiSigScriptHash:bt,PublicKeyHashInput:It}=Ot;const{BufferReader:xt}=St;const vt=t=>new Promise(e=>setTimeout(e,t));class Pt extends mt{constructor(t){super(t),this._outputData=[],Object.defineProperty(this,"to",_(this._to)),Object.defineProperty(this,"from",_(this._from))}get dataInputs(){const t=[];const e=function*(t){for(const e of t)yield e}(this.inputs);let s=e.next();for(;!s.done;){const n=s.value;if("MultiSigScriptHashInput"===n.constructor.name)t.push(A.fromMultiSigScriptHashInput(n));else if("PublicKeyHashInput"===n.constructor.name)t.push($.fromPublicKeyHashInput(n));else{if("Input"!==n.constructor.name)throw new Error(`unknown script class ${n.constructor.name}`);{const s=q.fromScript(n._scriptBuffer);if(s.isPublicKeyHashIn())t.push(new $(s.toAddress(),0));else if(q.isP2shScript(s)){let n=!1;const r=[q.redeemScriptFromP2shScript(s)];for(;!n;)try{t.push(A.fromRedeemScripts(r)),n=!0}catch(t){const s=e.next();if(s.done)throw new Error("Could not compute data inputs");const n=s.value;const o=q.fromScript(n._scriptBuffer);r.push(q.redeemScriptFromP2shScript(o))}}}}s=e.next()}return t}set dataInputs(t){throw Error("dataTransaction.dataInputs cannot be set directly, use dataTransaction.from or dataTransaction.fromScriptOutput")}get inputsWithData(){return this.dataInputs.filter(t=>"script"===t.kind)}async getVirtualInputs(){const{inputsWithData:t}=this;const e=A.addVouts(t);return Promise.all(e.map(async t=>{const e=[];if(t.__vouts.forEach(t=>{e.push(this.inputs[t])}),!e.every(t=>t.prevTxId.toString("hex")===e[0].prevTxId.toString("hex")))throw new Error("Something went wrong 1");const s=e[0].prevTxId.toString("hex");const n=await Pt.fromTxId(s);await n.fetchOutputData();const r=A.addVouts(n.outputData);const o=[];if(r.forEach((t,s)=>{et(t.__vouts,e.map(t=>t.outputIndex))&&o.push(s)}),o.length>1)throw new Error("Something went wrong 2");return{txId:s,virtualIndex:o[0]}}))}fromMultiSig(t,e,s){const n=t.map(t=>f("txId","txid",t));return super.from(n,e,s)}_from(t){const e=f("txId","txid",t);return super.from(e)}fromScriptOutput(t,e){const s=q.outScriptFromData(e);const{_owners:n}=e;return s.forEach(({redeemScript:e},s)=>{const{scriptPubKey:r,satoshis:o,txId:a,vout:i}=t[s];const c=new yt({script:new q(r),satoshis:parseInt(o,10)});const u=new q;const h=new bt({prevTxId:a,output:c,outputIndex:i,script:u},n,1,null,e);this.addInput(h)}),this}get outputData(){if(!this._outputData.length)throw new Error("dataTransaction.outputData is not initialized. Call dataTransaction.fetchDataOuptuts() first.");return this._outputData}set outputData(t){throw Error("dataTransaction.outputData cannot be set directly")}get outputsWithData(){return this.outputData.filter(t=>"script"===t.kind)}change(t){const e=this.outputs.length;return super.change(t),this.outputs.length>e&&this._outputData.push(new G(t)),this}toChangeOutput(t){const e=this.outputs.length;return super.change(t.address),this.outputs.length>e&&this._outputData.push(t),this._outputData.length-1}toPkhOutput(t){return super.to(t.address,t.amount),this._outputData.push(t),this._outputData.length-1}toScriptOutput(t){const e=q.outScriptFromData(t);return this._outputData.push(t),e.forEach(({redeemScript:e,chunk:s})=>{const n=q.buildScriptHashOut(e);const r=t._amount;const o=new yt({script:n,satoshis:r});this.addOutput(o)}),this._outputData.length-1}toReturnOutput(t){return this.addData(t.data),this._outputData.push(t),this._outputData.length-1}_to(t){switch(t.kind){case"change":return this.toChangeOutput(t);case"return":return this.toReturnOutput(t);case"script":return this.toScriptOutput(t);case"pkh":return this.toPkhOutput(t);default:throw new Error(`Unsupported output kind ${t.kind}`)}}async fetchOutputData(){if(this._outputData.length)return this._outputData;const t=this.getTxId();const e=await E(t);return this._outputData=e.map(pt.fromJSON),this._outputData}get prevObjectIds(){return this.inputs.map(t=>({txId:t.prevTxId.toString("hex"),virtualIndex:t.outputIndex}))}getTxId(){return new xt(this._getHash()).readReverse().toString("hex")}static async fromTxId(t){let e=null;try{e=await v(t)}catch(s){await vt(3e3),e=await v(t)}const s=new Pt;return await s.fromString(e),s}}class Nt{async eval(t){return eval(t)}async apply(t,e,s){return{res:t[e](...s),obj:t}}}class kt{constructor(){return new Nt}async eval(t){return this.sandbox.eval(t)}async apply(t,e,s){return this.sandbox.apply(t,e,s)}}const Et=t=>new Promise(e=>setTimeout(e,t));class Dt{constructor(t={}){const{id:e,target:s={},db:n=new lt,sandbox:o=new kt,eventEmitter:a=new r,socket:i}=t;this._id=e,this._rev=e,this.__target=s,this.db=n,this.sandbox=o,this.eventEmitter=a,this.socket=i,this.socket.on("message",this.onWebsocketMessage.bind(this)),this._initialized=!1,this.poll()}async poll(){for(;!this._initialized;)try{await x(this._id.txId),this._initialized=!0}catch(t){await Et(500)}this.eventEmitter.emit("initialized")}async onWebsocketMessage({data:t}){try{const{txId:e}=JSON.parse(t)||{};const s=await Pt.fromTxId(e);await s.fetchOutputData();const{__func:n,_args:r}=s.outputData[0];const o=await s.getVirtualInputs();const a=o.findIndex(t=>et(t,this._rev));if("constructor"===n||-1===a)return;const i=await Promise.all(o.map(async t=>et(t,this._rev)?this.__target:Dt.getObjectAt(t,this.sandbox)));let c=0;const[u,...h]=i;const d=r.map(t=>"__"===t?h[c++]:t);await this.sandbox.apply(u,n,d),this._rev={txId:e,virtualIndex:a},this.eventEmitter.emit("updated")}catch(t){throw console.log("Error on websocket message",t),t}}static async getObjectAt(t,e){const s=await Pt.fromTxId(t.txId);await s.fetchOutputData();const n=await s.getVirtualInputs();const r=await Promise.all(n.map(async t=>Dt.getObjectAt(t,e)));const{__func:o,_args:a,__cls:i}=s.outputData[0];let c=null;let u=0;if("constructor"===o){const t=r;const s=a.map(e=>"__"===e?t[u++]:e);c=[new(await e.eval(`(${i})`))(...s),...s]}else{const[t,...s]=r;const n=a.map(t=>"__"===t?s[u++]:t);await e.apply(t,o,n),c=[t,...n]}return c[t.virtualIndex]}get(t,e){if("_id"===e||"_rev"===e||"_initialized"===e)return Reflect.get(this,e);if("_owners"===e||"_amount"===e)return Reflect.get(this.__target,e);if("__target"===e)return this.__target;if("_on"===e||"_once"===e)return(t,s)=>this.eventEmitter[e.substring(1)](t,s);if("_close"===e)return()=>{this.eventEmitter.removeAllListeners(),this.socket.disconnect(!0)};if("string"==typeof e&&e.startsWith("_"))throw new Error(`Access to property ${e} denied`);return t&&e&&"function"!=typeof t[e]?Reflect.get(t,e):Object.prototype.hasOwnProperty.call(t.constructor.prototype,e)?async(...t)=>{const s=await global.computer.update(this,e,t);await this.db.update(global.computer.oldRevs,global.computer.newOutputs),global.computer.reset();const{eventEmitter:n}=this;return new Promise(t=>{n.once("updated",()=>{t(s)})})}:Reflect.get(t,e)}set(t,e,s){if("_rev"===e)return this._rev=s,!0;throw new Error("Cannot set property of smart object")}}class Tt{constructor(t){this.publicKey=t,this.newOutputs=[],this.oldRevs=[]}static encode(t,e){const{res:s}=nt([t,...e]);const n=s.shift();const r=Object.values(n);return s[0]._partition=r,s}static decode(t){const e=t[0]._partition;delete t[0]._partition;const s={};let n=0;for(const t of e)s[n]=t,n+=1;t.unshift(s);const r=rt(t);return{target:r.shift(),params:r}}new(t,e=[]){const s=e.filter(t=>t._rev);const n=e.map(t=>t._rev?"__":t);const r=e.map(t=>t._rev?t.__target:t);const o=s.map(t=>t._rev);const a=new t(...r);a._owners=a._owners||[this.publicKey.toString()],a._amount=a._amount||l.MIN_NON_DUST_AMOUNT;const i=Tt.encode(a,s);i[0].__cls=t.toString(),i[0].__func="constructor",i[0]._args=n;const c=i.map(A.fromJSON.bind(this));return this.oldRevs=[...o],this.newOutputs=c,a}async update(t,e,s){const{__target:n,_rev:r,sandbox:o}=t;const a=s.filter(t=>t._rev);const i=s.map(t=>t._rev?"__":t);const c=s.map(t=>t._rev?t.__target:t);const u=a.map(t=>t._rev);const h=st(n);const{res:d,obj:p}=await o.apply(h,e,c);const l=Tt.encode(h,a);l[0].__func=e,l[0]._args=i,l[0]._owners=p._owners||h.owners,l[0]._amount=p._amount||h._amount;const m=l.map(A.fromJSON.bind(this));return this.oldRevs=[r,...u],this.newOutputs=m,d}reset(){this.oldRevs=[],this.newOutputs=[]}}const{Mnemonic:Kt}=s;const Rt=async(t,e)=>new Promise(s=>{t._initialized||t._once(e,s)});class Ut{constructor(t={}){const{seed:s,mnemonic:n=new Kt(s),db:r=lt.fromMnemonic(n),sandbox:o=new kt}=t;this.db=r,this.sandbox=o,this.socket=e.connect(l.UN_P2SH_URL),global.computer=new Tt(this.db.wallet.getPublicKey())}_createSmartObject(t,e){const{db:s,socket:n}=this;const r=new Dt({id:e,target:t,db:s,socket:n});return new Proxy(t,r)}async new(t,e=[]){const s=global.computer.new(t,e);const n=await this.db.update(global.computer.oldRevs,global.computer.newOutputs);global.computer.reset(),e.filter(t=>t._rev).forEach((t,e)=>{t._rev=n[e+1]});const r=this._createSmartObject(s,n[0]);return await Rt(r,"initialized"),r}async sync(t){const e=await Dt.getObjectAt(t,this.sandbox);return this._createSmartObject(e,t)}close(){this.socket.disconnect(!0)}static async getOlder(t){const{txId:e,virtualIndex:s}=t[0];const n=await Pt.fromTxId(e);return await n.fetchOutputData(),"constructor"!==n.outputData[s].__func&&[{txId:n.inputs[0].prevTxId.toString("hex"),virtualIndex:n.inputs[0].outputIndex}]}static async getOldest(t){const e=await this.getOlder(t);return e?this.getOldest(e):t}}module.exports=Ut;
